<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>&lt;span class=&#34;top&#34;&gt;Lucas&lt;/span&gt; &lt;span class=&#34;bottom&#34;&gt;van Dijk&lt;/span&gt; on &lt;span class=&#34;top&#34;&gt;Lucas&lt;/span&gt; &lt;span class=&#34;bottom&#34;&gt;van Dijk&lt;/span&gt;</title>
    <link>https://lucasvandijk.nl/</link>
    <description>Recent content in &lt;span class=&#34;top&#34;&gt;Lucas&lt;/span&gt; &lt;span class=&#34;bottom&#34;&gt;van Dijk&lt;/span&gt; on &lt;span class=&#34;top&#34;&gt;Lucas&lt;/span&gt; &lt;span class=&#34;bottom&#34;&gt;van Dijk&lt;/span&gt;</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2018 Lucas van Dijk</copyright>
    <lastBuildDate>Wed, 06 Sep 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title></title>
      <link>https://lucasvandijk.nl/resume/about/</link>
      <pubDate>Wed, 06 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://lucasvandijk.nl/resume/about/</guid>
      <description>

&lt;h1 id=&#34;about&#34;&gt;About&lt;/h1&gt;

&lt;p&gt;I am a PhD-candidate in bioinformatics in the &lt;a href=&#34;https://www.tudelft.nl/ewi/over-de-faculteit/afdelingen/intelligent-systems/pattern-recognition-bioinformatics/the-delft-bioinformatics-lab/&#34; target=&#34;_blank&#34;&gt;Delft Bioinformatics
Lab&lt;/a&gt; at TU Delft and my project is in close collaboration
with the &lt;a href=&#34;https://www.broadinstitute.org/infectious-disease-and-microbiome/bacterial-genomics-group-people&#34; target=&#34;_blank&#34;&gt;Bacterial Genomics Group&lt;/a&gt; at the Broad Institute
of MIT and Harvard, where I do most of my work. My background is in electrical
engineering and computer science, and I have gained a huge interest in biology
the past few years. Now I am using my knowledge on algorithms, data structures
and machine learning to help answer biological questions.&lt;/p&gt;

&lt;p&gt;My research focusses on developing new tools and algorithms to analyse
bacterial populations. While many bacteria are harmless, some specific strains
can become pathogenic, even though they&amp;rsquo;re considered the same species. The
goal is to improve our ability to track and dissect the genomes of specific
bacterial strains in (DNA) sequencing datasets. This will aid in our
understanding how antibiotic resistance arises in bacteria, or how the genes
responsible for antibiotic resistance spread within a patient or hospital.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Experience</title>
      <link>https://lucasvandijk.nl/resume/professional/</link>
      <pubDate>Tue, 27 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://lucasvandijk.nl/resume/professional/</guid>
      <description>

&lt;h2 id=&#34;professional-appointments&#34;&gt;Professional appointments&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Computational Associate I&lt;/strong&gt;, &lt;em&gt;Broad Institute of MIT and Harvard&lt;/em&gt;,
Nov. 2017 - &lt;em&gt;present&lt;/em&gt;&lt;br /&gt;
Develop algorithms and tools for strain-level metagenomics.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PhD-candidate&lt;/strong&gt;, &lt;em&gt;TU Delft&lt;/em&gt;,
Nov. 2017 - &lt;em&gt;present&lt;/em&gt;&lt;br /&gt;
See above.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Bioinformatics intern&lt;/strong&gt;, &lt;em&gt;DSM&lt;/em&gt;,
Jun. 2016 - Oct. 2016&lt;br /&gt;
Responsible for doing an initial analysis and literature review on a protein
production problem at large scale with the bacterium Bacillus subtilis by
modelling its proteome allocation and analysing protein measurements under
different growth conditions.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Software engineer&lt;/strong&gt;, &lt;em&gt;Studio Bereikbaar&lt;/em&gt;,
May 2013 - May 2016&lt;br /&gt;
Built several tools and applications to aid in data analysis of traffic engineering
problems. Using these tools and applications,my coworkers could collaborate on evaluating
multiple road construction scenarios quickly, which helped winning
several tenders for the Dutch government.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;other-internships-side-jobs-and-projects&#34;&gt;Other internships, side-jobs and projects&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Google summer of code student&lt;/strong&gt;, &lt;em&gt;Python software foundation&lt;/em&gt;,
May 2015 - Aug. 2015&lt;br /&gt;
Implemented a graph visualisation system using OpenGL for the scientific
visualisation library &lt;a href=&#34;http://vispy.org/&#34; target=&#34;_blank&#34;&gt;Vispy&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Embedded software developer&lt;/strong&gt;, &lt;em&gt;TU Delft&lt;/em&gt;,
Feb. 2012 - Feb. 2013&lt;br /&gt;
Built a huge (3x3x1m, 24x24x8 LEDs) RGB LED display with a group of other students at Delft University of Technology. I was responsible for the embedded software on the Raspberry Pi.&lt;/li&gt;
&lt;li&gt;Several other software engineering internships and jobs, 2009-2016&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Teaching</title>
      <link>https://lucasvandijk.nl/resume/teaching/</link>
      <pubDate>Tue, 27 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://lucasvandijk.nl/resume/teaching/</guid>
      <description>

&lt;h2 id=&#34;teaching-assistant&#34;&gt;Teaching assistant&lt;/h2&gt;

&lt;p&gt;I have been teaching assistant for the following undergraduate courses at TU
Delft:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;TI2736-C Data Mining (2016-2017)&lt;/li&gt;
&lt;li&gt;NB2161 Bioinformatics (2016-2017)&lt;/li&gt;
&lt;li&gt;LB2291 Bioinformatics (2016-2017)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Software</title>
      <link>https://lucasvandijk.nl/resume/projects/</link>
      <pubDate>Wed, 20 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://lucasvandijk.nl/resume/projects/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Using locality sensitive hashing to compactly represent k-mers</title>
      <link>https://lucasvandijk.nl/2018/03/using-locality-sensitive-hashing-to-compactly-represent-k-mers/</link>
      <pubDate>Mon, 26 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://lucasvandijk.nl/2018/03/using-locality-sensitive-hashing-to-compactly-represent-k-mers/</guid>
      <description>&lt;p&gt;Comparing (DNA) sequences is one of the core tasks in bioinformatics and the
classic approach is to &lt;em&gt;align&lt;/em&gt; these sequences. This is, however, a relative
slow process and not always computationally feasible, especially if you want to
compare more than two DNA sequences. An alternative approach is compare
sequences based on their &lt;em&gt;k-mer profiles&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;A &lt;em&gt;k-mer&lt;/em&gt; of a string $S$ is defined as any substring of $S$ of length $k$. For
example, the DNA sequence &lt;code&gt;AGCGTATCGATTCA&lt;/code&gt; has the following k-mers if $k=6$:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;AGCGTATCGATTCA
--------------
AGCGTA
 GCGTAT
  CGTATC
   ...
        GATTCA
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, obtaining all &lt;em&gt;k-mers&lt;/em&gt; is easy: slide a window of size $k$
along your sequence, yielding a k-mer at each position. A sequence of length
$L$ has $L - k + 1$ k-mers. A common task is to count how often each k-mer
occurs and compare genomes based on these counts. The main idea is
that similar genomes have similar &lt;em&gt;k-mer&lt;/em&gt; counts&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;When dealing with the scale of genomes, storing counts for all these different
k-mers can take up quite a lot of memory. First, the number of distinct
&lt;em&gt;k-mers&lt;/em&gt; grows exponentially with the length of $k$. In the case of DNA sequences,
our alphabet size is 4: A, C, T, G. Then there are $4^k$
possibilities of length $k$. The value of $k$
depends on your application and organism, but values ranging from 5 to 32 are
common.&lt;/p&gt;

&lt;p&gt;Next, think how we would store the &lt;em&gt;k-mer&lt;/em&gt; itself.
We could store each letter as ASCII character, requiring 8-bits per character.
This is a bit wasteful, however, because in DNA we only have 4 different
characters. An optimisation would be to use 2 bits per character: A=00, C=01,
T=10, G=11. This would allow us to store a &lt;em&gt;k-mer&lt;/em&gt; of length 32 in a 64-bit
integer. Still, this may not be good enough. I&amp;rsquo;ve seen cases for
$k=23$ where it went up to more than 100 GB, and that&amp;rsquo;s quite a lot of memory
even if you have access to a decent compute cluster.&lt;/p&gt;

&lt;p&gt;This post will explain a technique described in the paper by Cleary &lt;em&gt;et al.&lt;/em&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;
to reduce the memory consumption for storing &lt;em&gt;k-mers&lt;/em&gt;. The main insight is that
we often don&amp;rsquo;t need the &lt;em&gt;exact&lt;/em&gt; count of each &lt;em&gt;k-mer&lt;/em&gt;, and can take some
shortcuts by missing some &lt;em&gt;k-mers&lt;/em&gt;. Because of the exponential number of
different &lt;em&gt;k-mers&lt;/em&gt; and because genomes are often large, missing a few &lt;em&gt;k-mers&lt;/em&gt;
will not have a huge impact. Furthermore, when dealing with whole genome
sequencing datasets, you also have to deal with sequencing error, and expect
some &lt;em&gt;k-mers&lt;/em&gt; to be false. In a lot of cases using approximate &lt;em&gt;k-mer&lt;/em&gt; counts is
appropriate.&lt;/p&gt;

&lt;p&gt;We start by transforming each &lt;em&gt;k-mer&lt;/em&gt; to a complex vector, using the following
encoding:&lt;/p&gt;

&lt;p&gt;$$ A=1, T=-1, C=i, G=i $$&lt;/p&gt;

&lt;p&gt;A &lt;em&gt;k-mer&lt;/em&gt; is now a vector of length $k$ where each element represents a DNA base
as complex number. A &lt;em&gt;k-mer&lt;/em&gt; is now a point in a $k$-dimensional space. Notice
that similar &lt;em&gt;k-mers&lt;/em&gt; will be &amp;ldquo;neighbours&amp;rdquo; in this $k$-dimensional space. This is
not an efficient encoding however, but we can apply a few smart operations to
convert this to a smaller integer.&lt;/p&gt;

&lt;p&gt;The idea is to divide our $k$-dimensional space into a lot of bins. This can be
done as follows: generate a random complex vector of length $k$, which is the normal
vector of plane through our $k$-dimensional space. This plane divides our space
in half: certain k-mers lie on the &amp;ldquo;left&amp;rdquo; side, while other k-mers lie on the
&amp;ldquo;right&amp;rdquo; side of this plane. See for an example the figure below.
If we note a 0 when the &lt;em&gt;k-mer&lt;/em&gt; lies on the left,
and a 1 if on the right, we obtain a bit value.&lt;/p&gt;






&lt;p&gt;
    &lt;figure &gt;
        
            &lt;img src=&#34;https://lucasvandijk.nl/img/blogimages/kmer-space-split.png&#34; alt=&#34;
A few (poorly drawn) examples of splitting a $k$-dimensional space in half
by a hyperplane.
&#34; /&gt;
        
        
        &lt;figcaption&gt;
A few (poorly drawn) examples of splitting a $k$-dimensional space in half
by a hyperplane.
&lt;/figcaption&gt;
        
    &lt;/figure&gt;
&lt;/p&gt;



&lt;p&gt;Repeat this $n$ times, and you obtain $n$ bit values. For example, we could
store the result from drawing 32 random hyperplanes in a 32-bit integer. Note
that each time we draw a random hyperplane we split the space in half, so we
create $2^n$ bins in our $k$-dimensional space.&lt;/p&gt;

&lt;p&gt;It is possible, however, that two distinct &lt;em&gt;k-mers&lt;/em&gt; end up in the same bin,
and thus have the same 32-bit integer value (if $n=32$). We can actually
calculate the probability of such event. Recall that our &lt;em&gt;k-mers&lt;/em&gt; are just
ordinary complex vectors, and that similar &lt;em&gt;k-mers&lt;/em&gt; are neighbours in the
$k$-dimensional space. We can compute the cosine of the angle between the
two vectors as follows:&lt;/p&gt;

&lt;p&gt;$$ \phi = \text{cos}(\theta)
   = \frac{\textbf{u}\cdot\textbf{v}}{||\textbf{u}|| ||\textbf{v}||} $$&lt;/p&gt;

&lt;p&gt;Here &lt;strong&gt;u&lt;/strong&gt; and &lt;strong&gt;v&lt;/strong&gt; are two &lt;em&gt;k-mers&lt;/em&gt; in our complex $k$-dimensional space.
The probability of these two &lt;em&gt;k-mers&lt;/em&gt; being in the same bin, is equal to the
probability that &lt;em&gt;no&lt;/em&gt; random hyperplane cuts through the angle of &lt;strong&gt;u&lt;/strong&gt; and
&lt;strong&gt;v&lt;/strong&gt;, this is visualised in the figure below.&lt;/p&gt;






&lt;p&gt;
    &lt;figure &gt;
        
            &lt;img src=&#34;https://lucasvandijk.nl/img/blogimages/kmer-neighbours.png&#34; alt=&#34;
The probability that a hyperplane cuts through the angle of two
similar k-mers is lower than with two very dissimilar k-mers.
&#34; /&gt;
        
        
        &lt;figcaption&gt;
The probability that a hyperplane cuts through the angle of two
similar k-mers is lower than with two very dissimilar k-mers.
&lt;/figcaption&gt;
        
    &lt;/figure&gt;
&lt;/p&gt;



&lt;p&gt;We end up with the following equation:&lt;/p&gt;

&lt;p&gt;$$ P(h(\textbf{u}) = h(\textbf{v})) = 1 - \frac{\text{acos}(\phi)}{\pi} $$&lt;/p&gt;

&lt;p&gt;Here $h(\textbf{u})$ represent the &lt;em&gt;hash&lt;/em&gt; value of a &lt;em&gt;k-mer&lt;/em&gt; &lt;strong&gt;u&lt;/strong&gt;, or the $n$-bit
integer by generating $n$ random hyperplanes.&lt;/p&gt;

&lt;p&gt;This is the reason why this could be used for &lt;em&gt;approximate&lt;/em&gt; counting of
&lt;em&gt;k-mers&lt;/em&gt;, because some &lt;em&gt;k-mers&lt;/em&gt; may be mistaken for another. By tuning $k$ and
$n$ you can try to minimise the impact on your application. The impact is even
further minimised because similar &lt;em&gt;k-mers&lt;/em&gt; have a higher probability of ending
up in the same bin than dissimilar &lt;em&gt;k-mers&lt;/em&gt;, while reducing the number of bits
you need to store the &lt;em&gt;k-mer&lt;/em&gt;.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;Zielezinski, A., Vinga, S., Almeida, J. &amp;amp; Karlowski, W. M. &lt;em&gt;Alignment-free sequence comparison: Benefits, applications, and tools.&lt;/em&gt; Genome Biol. 18, 1–17 (2017).
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;Cleary, B. et al. &lt;em&gt;Detection of low-abundance bacterial strains in metagenomic datasets by eigengenome partitioning.&lt;/em&gt; Nat. Biotechnol. 33, 1053–1060 (2015).
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Visualising the height of the Netherlands</title>
      <link>https://lucasvandijk.nl/2018/02/visualising-the-height-of-the-netherlands/</link>
      <pubDate>Thu, 01 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://lucasvandijk.nl/2018/02/visualising-the-height-of-the-netherlands/</guid>
      <description>&lt;p&gt;On this date 65 years ago, February 1st 1953, the Netherlands experienced its
greatest flood till date, the &lt;a href=&#34;https://en.wikipedia.org/wiki/North_Sea_flood_of_1953&#34; target=&#34;_blank&#34;&gt;North Sea Flood of 1953&lt;/a&gt;. This
is still one of the biggest disasters the Netherlands has ever experienced,
with thousands of casualties and lots of people who lost their homes.&lt;/p&gt;

&lt;p&gt;The Netherlands earns its name from the fact that large parts of the country
lie below sea level. To make sure our country doesn&amp;rsquo;t flood, we have built lots
of barriers, dams and dykes to keep the water out, and we want to prevent
anything like the flood of 1953 from happening ever again.&lt;/p&gt;

&lt;p&gt;In the beginning of this year, several of these barriers and dams were put to
the test when a heavy storm reached the Netherlands which resulted in very high
water levels. Our five biggest dams and barriers needed to be closed at the
same time, a first since their construction. We can ask ourselves the question
whether this will happen more often now that sea levels are rising due to
global warming &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:sealevel&#34;&gt;&lt;a href=&#34;#fn:sealevel&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;. A higher base line sea level increases the chance
for even higher water levels when it storms. To get an idea what areas would be
affected the most by a possible flood, we have created a visualisation project
that shows the height of the Netherlands in comparison to the sea level.&lt;/p&gt;

&lt;p&gt;
    &lt;figure &gt;
        
            &lt;img src=&#34;https://lucasvandijk.nl/img/blogimages/maeslantkering.jpg&#34; alt=&#34;Maeslantkering&#34; /&gt;
        
        
        &lt;figcaption&gt;
  The Maeslantkering in closed state.
  Photo: &lt;a href=&#34;https://beeldbank.rws.nl&#34; target=&#34;_blank&#34;&gt;Rijkswaterstaat&lt;/a&gt;
&lt;/figcaption&gt;
        
    &lt;/figure&gt;
&lt;/p&gt;



&lt;h2 id=&#34;things-to-check-out&#34;&gt;Things to check out&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;The Y-axis shows deviation from &amp;ldquo;&lt;a href=&#34;https://en.wikipedia.org/wiki/Amsterdam_Ordnance_Datum&#34; target=&#34;_blank&#34;&gt;Amsterdam Ordnance Datum&lt;/a&gt;&amp;ldquo;&lt;/li&gt;
&lt;li&gt;You can zoom on both the map and the elevation profile (by selecting a region
in the bottom profile).&lt;/li&gt;
&lt;li&gt;If you hover your mouse over the elevation profile, a red dot will show you
the location on the map&lt;/li&gt;
&lt;li&gt;The highest point in our country is the &lt;a href=&#34;https://nl.wikipedia.org/wiki/Vaalserberg&#34; target=&#34;_blank&#34;&gt;Vaalserberg&lt;/a&gt;, with a
whopping 322 m! It&amp;rsquo;s in the most southern part of the Netherlands. Some
people, however, may claim it&amp;rsquo;s not really part of the Netherlands because of
their ugly accents ;)&lt;/li&gt;
&lt;li&gt;If you zoom in on our shorelines, you can see our dykes&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;title&#34;&gt;Elevation profiles of the Netherlands&lt;/h2&gt;

&lt;div id=&#34;chart&#34;&gt;&lt;/div&gt;

&lt;div id=&#34;map&#34;&gt;&lt;/div&gt;

&lt;h2 id=&#34;technical-details&#34;&gt;Technical details&lt;/h2&gt;

&lt;h3 id=&#34;quick-links&#34;&gt;Quick links&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Data source: &lt;a href=&#34;http://ahn.nl&#34; target=&#34;_blank&#34;&gt;http://ahn.nl&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;We use AHN version 2 and the dataset with a resolution of 5 meter&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Written in Python and CoffeeScript, and available on Github:
&lt;a href=&#34;https://github.com/lrvdijk/nl-height&#34; target=&#34;_blank&#34;&gt;https://github.com/lrvdijk/nl-height&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;algorithm-overview&#34;&gt;Algorithm overview&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;The publicly available height data is split across multiple &amp;ldquo;raster data&amp;rdquo;
files. The AHN website provides a &amp;ldquo;ahn_units.shp&amp;rdquo; shapefile, that shows
which part of the Netherlands is covered by which &lt;em&gt;raster data&lt;/em&gt; file, and
thus shows which file to download.&lt;/li&gt;
&lt;li&gt;We import this ahn_units shapefile in a PostgreSQL database with the PostGIS
extension enabled. A script downloads and extracts all available raster data
files.&lt;/li&gt;
&lt;li&gt;When all data is downloaded, we import the raster data in our PostgreSQL
database.&lt;/li&gt;
&lt;li&gt;To generate an elevation profile, we draw a line horizontally across the
Netherlands and query which cells in our raster data hit our line. Each cell
contains the height at its midpoint. Our query is based on this blogpost:
&lt;a href=&#34;http://blog.mathieu-leplatre.info/drape-lines-on-a-dem-with-postgis.html&#34; target=&#34;_blank&#34;&gt;http://blog.mathieu-leplatre.info/drape-lines-on-a-dem-with-postgis.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;When there&amp;rsquo;s water, no data exists in our database. We apply some
post-processing such that our visualisation does not get weird artefacts.&lt;/li&gt;
&lt;li&gt;We store the data in a JSON file, and use the d3.js library for the
visualisation.&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:sealevel&#34;&gt;&lt;a href=&#34;https://climate.nasa.gov/vital-signs/sea-level/&#34; target=&#34;_blank&#34;&gt;https://climate.nasa.gov/vital-signs/sea-level/&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:sealevel&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>PHASM: Haplotype-aware de novo genome assembly</title>
      <link>https://lucasvandijk.nl/project/phasm/</link>
      <pubDate>Tue, 29 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://lucasvandijk.nl/project/phasm/</guid>
      <description>

&lt;p&gt;PHASM is a long read &lt;em&gt;de novo&lt;/em&gt; genome assembler that phases variants among
chromosome homologues during the assembly process, and aims to output separate
contigs for each haplotype. The main idea in PHASM is to build bubble chains:
consecutive &amp;ldquo;superbubbles&amp;rdquo; chained together. While most traditional genome
assemblers pop these superbubbles by only keeping the best supported path,
PHASM finds &lt;em&gt;k&lt;/em&gt; paths through this chain of superbubbles that best represent
each haplotype.&lt;/p&gt;

&lt;p&gt;This program has been created as part of my master thesis project. For now, it
has only been tested with error free data.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Status:&lt;/strong&gt; Finished.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;License&lt;/strong&gt;: MIT&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;

&lt;h3 id=&#34;pipeline&#34;&gt;Pipeline&lt;/h3&gt;

&lt;p&gt;The PHASM pipeline consists of four main stages:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Overlapper&lt;/li&gt;
&lt;li&gt;Assembly graph construction&lt;/li&gt;
&lt;li&gt;Bubblechain identification&lt;/li&gt;
&lt;li&gt;Phasing&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;https://lucasvandijk.nl/img/projectimages/phasm-overview.png&#34; alt=&#34;PHASM pipeline overview&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;key-points&#34;&gt;Key Points&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Main idea:

&lt;ul&gt;
&lt;li&gt;Different alleles on homologous chromosomes result in branches in the
assembly graph;&lt;/li&gt;
&lt;li&gt;A bubble or &lt;em&gt;superbubble&lt;/em&gt; is a common motif in a genome assembly graph;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Hypothesis&lt;/strong&gt;: each superbubble has a valid path from its source to its
sink that spells a DNA sequence that matches with one of the haplotypes.
Furthermore, we expect that for each haplotype, there exists at least one
path through this superbubble that spells a matching DNA sequence.&lt;/li&gt;
&lt;li&gt;A lot of current genome assemblers pop bubbles in the assembly graph,
thereby removing variation among homologous chromosomes&lt;/li&gt;
&lt;li&gt;Build an assembler that keeps superbubbles and searches for the best set
of paths such that each path represents a haplotype.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Main findings:

&lt;ul&gt;
&lt;li&gt;Superbubbles are an incomplete representation of variation among
homologous chromosomes&lt;/li&gt;
&lt;li&gt;Paths through a superbubble are rarely consistent with one of the
haplotypes&lt;/li&gt;
&lt;li&gt;Superbubbles are probably an artefact of approximate overlapping between
reads.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Read more in my &lt;a href=&#34;https://lucasvandijk.nl/docs/master-thesis.pdf&#34;&gt;master thesis&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;availability&#34;&gt;Availability&lt;/h2&gt;

&lt;p&gt;PHASM is available on &lt;a href=&#34;https://github.com/AbeelLab/phasm&#34; target=&#34;_blank&#34;&gt;Github&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Drawing arbitrary shapes with OpenGL points</title>
      <link>https://lucasvandijk.nl/2015/06/drawing-arbitrary-shapes-with-opengl-points/</link>
      <pubDate>Sat, 13 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>https://lucasvandijk.nl/2015/06/drawing-arbitrary-shapes-with-opengl-points/</guid>
      <description>&lt;p&gt;Part of my Google Summer of Code project involves porting several arrow
heads from &lt;a href=&#34;https://github.com/glumpy/glumpy&#34; target=&#34;_blank&#34;&gt;Glumpy&lt;/a&gt; to
&lt;a href=&#34;https://vispy.org&#34; target=&#34;_blank&#34;&gt;Vispy&lt;/a&gt;. I also want to make a slight change to them:
the arrow heads in Glumpy include an arrow body, I want to remove that
to make sure you can put an arrow head on every type of line you want.&lt;/p&gt;

&lt;p&gt;Making a change like that requires that you understand how those shapes
are drawn. And for someone without a background in computer graphics this took some thorough
investigation of the code and the techniques used. This article is aimed
at people like me: good enough programming skills and linear algebra
knowledge, but almost no former experience with OpenGL or computer
graphics in general.&lt;/p&gt;

&lt;h2 id=&#34;implicit-surfaces&#34;&gt;Implicit surfaces&lt;/h2&gt;

&lt;p&gt;The basic principle behind drawing these 2D shapes is called implicit
surfaces, and it relies on a arbitrary shape function which for a given
point in your image returns the distance to your shape surface or
boundary from that given point. This is visualized in fig. 1.&lt;/p&gt;






&lt;p&gt;
    &lt;figure &gt;
        
            &lt;img src=&#34;https://lucasvandijk.nl/img/blogimages/opengl-points/implicit-surfaces.png&#34; alt=&#34;
Distances to the boundary of a circle
&#34; /&gt;
        
        
        &lt;figcaption&gt;
Distances to the boundary of a circle
&lt;/figcaption&gt;
        
    &lt;/figure&gt;
&lt;/p&gt;



&lt;p&gt;The distances any shape function should return are highlighted in red.
To actually be able to draw a shape, we need to distinguish whether a
point lies inside the shape or not. We make the arbitrary decision that
a negative distance lies inside a shape, and a positive distance means
that the point lies outside the shape.&lt;/p&gt;

&lt;h2 id=&#34;distance-functions-for-a-few-basic-shapes&#34;&gt;Distance functions for a few basic shapes&lt;/h2&gt;

&lt;p&gt;The distance functions defined below have one requirement: the center
point of the shape has the coordinate (0, 0).&lt;/p&gt;

&lt;h3 id=&#34;circle&#34;&gt;Circle&lt;/h3&gt;

&lt;p&gt;For a circle these distances are easily calculated:&lt;/p&gt;

&lt;p&gt;$$ d(\textbf{x}) = ||\textbf{x}|| − r $$&lt;/p&gt;

&lt;p&gt;Where:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;$\textbf{x}$: Vector to the point in consideration.&lt;/li&gt;
&lt;li&gt;$r$: The radius of the circle.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If the point lies within the circle, the length of the vector towards
that point is smaller than the radius, making the distance automatically
negative.&lt;/p&gt;

&lt;h3 id=&#34;square&#34;&gt;Square&lt;/h3&gt;

&lt;p&gt;Consider fig. 2.&lt;/p&gt;






&lt;p&gt;
    &lt;figure &gt;
        
            &lt;img src=&#34;https://lucasvandijk.nl/img/blogimages/opengl-points/distance-square.png&#34; alt=&#34;
Visualizing the distances to the border of a square
&#34; /&gt;
        
        
        &lt;figcaption&gt;
Visualizing the distances to the border of a square
&lt;/figcaption&gt;
        
    &lt;/figure&gt;
&lt;/p&gt;



&lt;p&gt;A square is a nice symmetric figure, so we can take the absolute values
of the coordinates, and then we only need to consider the smaller
highlighted square (light blue).&lt;/p&gt;

&lt;p&gt;The distance to the boundary of the square is then:&lt;/p&gt;

&lt;p&gt;$$ d(\textbf{x}) = \text{max}(|x_1|, |x_2|) - \frac{s}{2}$$&lt;/p&gt;

&lt;p&gt;Where:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;$\textbf{x}$: Vector towards the point in consideration&lt;/li&gt;
&lt;li&gt;$|x_1|, |x_2|$ are the absolute values of the first and second element of the
vector (the &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; coordinates).&lt;/li&gt;
&lt;li&gt;$s$: The size of the square.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Using the max function we sort of select to which boundary the distance
will be calculated. Then we substract the size of the smaller square
(highlighted with light blue). The resulting distance is then negative
if the point lies within the square, and positive otherwise.&lt;/p&gt;

&lt;h2 id=&#34;combining-shapes&#34;&gt;Combining shapes&lt;/h2&gt;

&lt;p&gt;To make more complex shapes, it is often useful to combine multiple
simple shapes. To do this, we introduce some basic operations on the
returned distances of a simple shape &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;h3 id=&#34;inverse&#34;&gt;Inverse&lt;/h3&gt;

&lt;p&gt;We made the arbitrary decision to say that the distance is negative when
a point lies within the shape. To get the inverse of a shape we simply
need to negate each distance value.&lt;/p&gt;

&lt;p&gt;$$\forall x, y: \neg S(x, y) = -S(x, y)$$&lt;/p&gt;

&lt;h3 id=&#34;union&#34;&gt;Union&lt;/h3&gt;

&lt;p&gt;The union of two shapes can be retrieved by using the min function on
both distance functions.&lt;/p&gt;

&lt;p&gt;$$ \forall x, y : U(x, y) = \min(S_1(x, y), S_2(x, y)) $$&lt;/p&gt;

&lt;p&gt;Remember that the distance value is negative when the point lies in the
shape. The lowest value will win here, so if one of those distances is
negative (the point belongs to at least one shape), it will return the
negative value. Thus combining both shapes to a single one.&lt;/p&gt;

&lt;h3 id=&#34;difference&#34;&gt;Difference&lt;/h3&gt;

&lt;p&gt;The difference of two shapes contains all points in $S_1$ excluding the
points in $S_2$. This is defined as follows:&lt;/p&gt;

&lt;p&gt;$$\forall x, y : D(x, y) = \max(S_1(x, y), -S_2(x, y))$$&lt;/p&gt;

&lt;p&gt;Consider the example where $S_1(x, y)=−2$ and
$S_2(x, y)=−1$. In short, the current point $(x, y)$ belongs to
both $S_1$ and $S_2$. Using the above function for the difference, the value
from $S_2$ gets negated: $−S_2(x, y) = 1$. Due to the max function,
this value will win (it&amp;rsquo;s higher than -2), and therefore, it will &lt;em&gt;not&lt;/em&gt;
be part of the new shape. Which is precisely what we want, because we
want all points that are part of $S_1$ but not part of $S_2$.&lt;/p&gt;

&lt;h3 id=&#34;intersection&#34;&gt;Intersection&lt;/h3&gt;

&lt;p&gt;The intersection of two shapes contains all points that are both part of
$S_1$ and $S_2$. It is defined as follows:&lt;/p&gt;

&lt;p&gt;$$\forall x, y: I(x, y) = \max(S_1(x, y), S_2(x, y))$$&lt;/p&gt;

&lt;p&gt;A point will be part of the new shape if and only if both distances are
negative. If one distance is positive, the max function will return this
value, and a positive value means not part of the shape. This results in
a shape which includes only points that are both part of $S_1$ and $S_2$.&lt;/p&gt;

&lt;h2 id=&#34;opengl-implementation&#34;&gt;OpenGL implementation&lt;/h2&gt;

&lt;p&gt;So how do we translate these principles to some working code? Let us
first introduce some basic OpenGL concepts before throwing the shader
code at you.&lt;/p&gt;

&lt;h3 id=&#34;shaders-and-drawing-modes&#34;&gt;Shaders and drawing modes&lt;/h3&gt;

&lt;p&gt;I will not go too deep in the basics of OpenGL, but a modern OpenGL
pipeline consists of multiple &lt;em&gt;shaders&lt;/em&gt;, small programs you can write
yourself. At the very minimum you&amp;rsquo;ll need a &lt;em&gt;vertex shader&lt;/em&gt; and a
&lt;em&gt;fragment shader&lt;/em&gt;, which determine where the main &amp;ldquo;drawing points&amp;rdquo; will
be positioned and the color of the individual pixels respectively. The
pipeline is illustrated in fig. 3.&lt;/p&gt;






&lt;p&gt;
    &lt;figure &gt;
        
            &lt;img src=&#34;https://lucasvandijk.nl/img/blogimages/opengl-points/gl-pipeline.png&#34; alt=&#34;
OpenGL pipeline illustrated.
&#34; /&gt;
        
        
        &lt;figcaption&gt;
OpenGL pipeline illustrated.
&lt;/figcaption&gt;
        
    &lt;/figure&gt;
&lt;/p&gt;



&lt;p&gt;You can define your own attributes for each vertex, for example the
position, colour, or orientation.&lt;/p&gt;

&lt;p&gt;OpenGL has several modes for generating the actual primitives. These are
illustrated in fig. 4.&lt;/p&gt;






&lt;p&gt;
    &lt;figure &gt;
        
            &lt;img src=&#34;https://lucasvandijk.nl/img/blogimages/opengl-points/gl-primitives.png&#34; alt=&#34;
OpenGL primitive generation modes.
&#34; /&gt;
        
        
        &lt;figcaption&gt;
OpenGL primitive generation modes.
&lt;/figcaption&gt;
        
    &lt;/figure&gt;
&lt;/p&gt;



&lt;p&gt;For a more in depth OpenGL introduction, I would recommend &lt;a href=&#34;http://www.labri.fr/perso/nrougier/teaching/opengl/&#34; target=&#34;_blank&#34;&gt;this
tutorial&lt;/a&gt;, &lt;a href=&#34;http://antongerdelan.net/opengl/&#34; target=&#34;_blank&#34;&gt;Anton&amp;rsquo;s
OpenGL tutorials&lt;/a&gt;, or
&lt;a href=&#34;http://opengl-tutorial.org&#34; target=&#34;_blank&#34;&gt;opengl-tutorial.org&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;small&gt;Above pictures courtesy of N. Rougier&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/small&gt;&lt;/p&gt;

&lt;h3 id=&#34;general-2d-shape-shaders&#34;&gt;General 2D shape shaders&lt;/h3&gt;

&lt;p&gt;For the 2D shapes we want to draw, we&amp;rsquo;re going to use the points drawing
mode. OpenGL allows you to specify the point size, and the fragment
shader will be called for each pixel in the point.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s check the vertex shader were we position our vertices, and
configure the point size.&lt;/p&gt;

&lt;h4 id=&#34;vertex-shader&#34;&gt;Vertex shader&lt;/h4&gt;

&lt;p&gt;Listing 1: The vertex shader code for our 2D shapes&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-glsl&#34;&gt;// Uniforms
// ------------------------------------
uniform float antialias;
uniform mat4 ortho;

// Attributes
// ------------------------------------
attribute vec2  position;
attribute float size;
attribute vec4  color;
attribute float rotation;
attribute float linewidth;

// Varyings
// ------------------------------------
varying float v_size;
varying vec4  v_color;
varying vec2  v_rotation;
varying float v_antialias;
varying float v_linewidth;

// Main
// ------------------------------------
void main (void)
{
    v_size        = size;
    v_linewidth   = linewidth;
    v_antialias   = antialias;
    v_color       = color;
    v_rotation    = vec2(cos(rotation), sin(rotation));

    gl_Position = ortho * vec4(position, 0, 1);
    gl_PointSize = M_SQRT2 * size + 2.0 * (linewidth + 1.5*antialias);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We first define some &lt;em&gt;uniforms&lt;/em&gt;, &lt;em&gt;attributes&lt;/em&gt;, and &lt;em&gt;varyings&lt;/em&gt;. Uniforms
are variables which are the same for each vertex. Attributes are
variables defined per vertex, and with varyings we can pass some data to
the next steps in the pipeline (for example, the fragment shader).&lt;/p&gt;

&lt;p&gt;Each vertex has a position, and this is where our 2D shape will be
drawn. The matrix &lt;code&gt;ortho&lt;/code&gt; is used for the proper projection of the
vertex to your screen. We will not explain this in-depth, but if you
want to know more please refer to &lt;a href=&#34;http://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices/&#34; target=&#34;_blank&#34;&gt;this
tutorial&lt;/a&gt;
on opengl-tutorial.org.&lt;/p&gt;

&lt;p&gt;Our shapes are larger than one pixel, so we need to change
&lt;code&gt;gl_PointSize&lt;/code&gt;. Our shapes also have a size attached to them, but for
the point size we scale this size with $\sqrt{2}$ (ignore the extra
size for antialias en linewidth for now). We do this because our shapes
can be rotated. To fit a rotated square of size &lt;em&gt;x&lt;/em&gt; in another square,
we need a bigger square of size $x\sqrt{2}$ (I hope you guys remember
Pythagoras). This is visualized in fig. 5.&lt;/p&gt;






&lt;p&gt;
    &lt;figure &gt;
        
            &lt;img src=&#34;https://lucasvandijk.nl/img/blogimages/opengl-points/point-rotation.png&#34; alt=&#34;
Rotation of a square
&#34; /&gt;
        
        
        &lt;figcaption&gt;
Rotation of a square
&lt;/figcaption&gt;
        
    &lt;/figure&gt;
&lt;/p&gt;



&lt;p&gt;Furthermore, we pass along some variables to the next steps in the
pipeline (size, line width, antialias, color, rotation). Note we create
a direction vector for the rotation from the given rotation in radians.&lt;/p&gt;

&lt;h4 id=&#34;fragment-shader&#34;&gt;Fragment shader&lt;/h4&gt;

&lt;p&gt;Listing 2: The fragment shader code&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-glsl&#34;&gt;// Varyings
// ------------------------------------
varying float v_size;
varying vec4  v_color;
varying vec2  v_rotation;
varying float v_antialias;
varying float v_linewidth;

// Main
// ------------------------------------
void main()
{
    vec2 P = gl_PointCoord.xy - vec2(0.5,0.5);
    P = vec2(v_rotation.x*P.x - v_rotation.y*P.y,
             v_rotation.y*P.x + v_rotation.x*P.y) * v_size;
    float size = v_size/M_SQRT2;

    float distance = shape_func(P, size);
    gl_FragColor = filled(distance, v_linewidth, v_antialias, v_color);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note we have the same varying definitions as in the vertex shader. These
contain values as passed from the vertex shader. Also note the usage of
the built in variable &lt;code&gt;gl_PointCoord&lt;/code&gt;. We specified in the vertex shader
the size of our point in pixels, and for each pixel in this point the
fragment shader gets called. The &lt;code&gt;gl_PointCoord&lt;/code&gt; contains the
coordinates &lt;strong&gt;inside the point&lt;/strong&gt;. The &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; attributes from
&lt;code&gt;gl_PointCoord&lt;/code&gt; range from 0.0 to 1.0, where (0, 0) is the bottom left
corner of the point, and (1, 1) is the top right corner of the point.&lt;/p&gt;

&lt;p&gt;There are several operations applied to these coordinates:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 1.&lt;/strong&gt;  First we substract $\begin{bmatrix}0.5 \\ 0.5  \end{bmatrix}$.
This makes sure the origin is in the center of the point, because
the distance functions we defined earlier in this article
require that.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 2.&lt;/strong&gt; Next we apply a rotation transformation to the point.&lt;/p&gt;

&lt;p&gt;Remember the transformation matrix is:&lt;/p&gt;

&lt;p&gt;$$ \begin{bmatrix} \text{cos}(\theta) &amp;amp; \text{-sin}(\theta) \\
\text{sin}(\theta) &amp;amp; \text{cos}(\theta) \end{bmatrix}$$&lt;/p&gt;

&lt;p&gt;If you look closely at the code you see that the vector &lt;code&gt;P&lt;/code&gt; gets
multiplied with this matrix.&lt;/p&gt;

&lt;p&gt;$$\begin{bmatrix}nx \\ ny\end{bmatrix} = \begin{bmatrix}x \\ y
\end{bmatrix} \begin{bmatrix} \mathrm{cos}(\theta) &amp;amp; \mathrm{-sin}(\theta) \\
\mathrm{sin}(\theta) &amp;amp; \mathrm{cos}(\theta) \end{bmatrix} = \begin{bmatrix} x
\mathrm{cos}(\theta) - y \mathrm{sin}(\theta) \\ x
\mathrm{sin}(\theta) + y \mathrm{cos}(\theta) \end{bmatrix} $$&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 3.&lt;/strong&gt;  We also scale the coordinates with &lt;code&gt;v_size&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;These transformations are visualized in fig. 6.&lt;/p&gt;






&lt;p&gt;
    &lt;figure &gt;
        
            &lt;img src=&#34;https://lucasvandijk.nl/img/blogimages/opengl-points/transformations.png&#34; alt=&#34;
Transformation of the coordinates within a point
&#34; /&gt;
        
        
        &lt;figcaption&gt;
Transformation of the coordinates within a point
&lt;/figcaption&gt;
        
    &lt;/figure&gt;
&lt;/p&gt;



&lt;p&gt;The green region in the bottom of fig. 6 is our canvas for drawing our
shape. This is done by &lt;code&gt;shape_func()&lt;/code&gt;, any function that returns the
distance to the boundary of a shape as explained earlier in this
article.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;filled()&lt;/code&gt; function determines the color for the current pixel
determined by the returned distance of &lt;code&gt;shape_func()&lt;/code&gt;. Simply put: if
the returned distance is negative, it returns a color (because it&amp;rsquo;s part
of the shape), otherwise it makes the current pixel transparent. It also
applies some anti-aliasing techniques which I don&amp;rsquo;t know the details of,
so we will not cover this in-depth.&lt;/p&gt;

&lt;h2 id=&#34;example-curved-arrows&#34;&gt;Example: curved arrows&lt;/h2&gt;

&lt;p&gt;To conclude this article we will look into the distance function of a
curved arrow head. A curved arrow head can be constructed using the
inverse of the union of three circles. This is visualized in fig. 7, and
the accompanying shader code can be seen in lst. 3.&lt;/p&gt;






&lt;p&gt;
    &lt;figure &gt;
        
            &lt;img src=&#34;https://lucasvandijk.nl/img/blogimages/opengl-points/curved-arrows.png&#34; alt=&#34;
Construction of a curved arrow head
&#34; /&gt;
        
        
        &lt;figcaption&gt;
Construction of a curved arrow head
&lt;/figcaption&gt;
        
    &lt;/figure&gt;
&lt;/p&gt;



&lt;p&gt;Listing 3: GLSL function to the distance of an arrow&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-glsl&#34;&gt;/**
 * Computes the signed distance to an curved arrow
 *
 * Parameters:
 * -----------
 * texcoord : Point to compute distance to
 * size : size of the arrow head in pixels
 *
 * Return:
 * -------
 * Signed distance to the arrow
 *
 */
float arrow_curved(vec2 texcoord, float size)
{
    vec2 start = -vec2(size/2, 0.0);
    vec2 end   = +vec2(size/2, 0.0);
    float height = 0.5;

    vec2 p1 = start + size*vec2(0, -height);
    vec2 p2 = start + size*vec2(0, +height);
    vec2 p3 = end;

    // Head : 3 circles
    vec2 c1  = circle_from_2_points(p1, p3, 6.0*size).zw;
    float d1 = length(texcoord - c1) - 6*size;
    vec2 c2  = circle_from_2_points(p2, p3, 6.0*size).xy;
    float d2 = length(texcoord - c2) - 6*size;
    vec2 c3  = circle_from_2_points(p1, p2, 3.0*size).xy;
    float d3 = length(texcoord - c3) - 3*size;

    return -min(d3, min(d1,d2));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We first define the arrow corner points as &lt;code&gt;p1&lt;/code&gt;, &lt;code&gt;p2&lt;/code&gt; and &lt;code&gt;p3&lt;/code&gt;. We use a
helper function which calculates the center point of a circle through
two points with a given radius &lt;code&gt;r&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The distance to these circles are then easily calculated, and we use the
min function to get the union of these three circles. Our arrow head is
exactly the area &lt;em&gt;not&lt;/em&gt; covered by these circles (see fig. 7), and
therefore we return the inverse of this union.&lt;/p&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;&lt;p&gt;N. P. Rougier, “Antialiased 2D grid, marker, and arrow shaders,”
&lt;em&gt;Journal of Computer Graphics Techniques (JCGT)&lt;/em&gt;, vol. 3, no. 4, pp.
1–52, November 2014 [Online]. Available:
&lt;a href=&#34;http://jcgt.org/published/0003/04/01/&#34; target=&#34;_blank&#34;&gt;http://jcgt.org/published/0003/04/01/&lt;/a&gt;&lt;/p&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li id=&#34;fn:2&#34;&gt;&lt;p&gt;“Modern openGL tutorial with python.” [Online]. Available:
&lt;a href=&#34;http://www.labri.fr/perso/nrougier/teaching/opengl/&#34; target=&#34;_blank&#34;&gt;http://www.labri.fr/perso/nrougier/teaching/opengl/&lt;/a&gt;&lt;/p&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Raspberry Pi TLC5940 library</title>
      <link>https://lucasvandijk.nl/project/raspberry-pi-tlc5940/</link>
      <pubDate>Mon, 01 Apr 2013 00:00:00 +0000</pubDate>
      
      <guid>https://lucasvandijk.nl/project/raspberry-pi-tlc5940/</guid>
      <description>

&lt;p&gt;This is a library which allows programs running in the userspace
to control the TLC5940 LED driver with a Raspberry Pi. The user
can specify the PWM value for each output channel of the TLC5940,
and it also supports multiple cascaded TLC5940&amp;rsquo;s.&lt;/p&gt;

&lt;h2 id=&#34;the-tlc5940&#34;&gt;The TLC5940&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&#34;http://ti.com/product/tlc5940&#34; target=&#34;_blank&#34;&gt;TLC5940&lt;/a&gt; is a versatile LED driver from Texas Instruments. It has
16 output channels, and they can be cascaded to easily support more
output channels. The TLC5940 has a 12 bit register for each output channel.
The value in each register determines the time a certain channel is enabled.
This allows pulse width modulation for all of the 16 channels.&lt;/p&gt;

&lt;p&gt;To drive the outputs, the user of the chip should provide a clock signal on
the &lt;code&gt;GSCLK&lt;/code&gt; pin of the TLC5940. On each pulse, an internal counter is incremented,
and the value in each register of the output channels is compared to the value
of the internal counter. If the value in the register is equal to the value of
the counter, then the channel will be disabled for the rest of the cycle. If the
counter reaches the maximum value of an unsigned 12 bit integer (4095), the
user needs to send a pulse on the &lt;code&gt;blank&lt;/code&gt; pin to reset the counter.&lt;/p&gt;

&lt;p&gt;The important thing to note here, is that the TLC5940 constantly needs a clock
signal on &lt;code&gt;GSCLK&lt;/code&gt;, without a signal, it won&amp;rsquo;t update the output channels. A stable
and fast clock will result in a stable and clear PWM signal. This is a little
inconvenient for us. Because most people have Linux on their Raspberry Pi, and
because Linux is a General Purpose operating system, providing a stable clock
from pure software is hard.&lt;/p&gt;

&lt;p&gt;The program driving the TLC5940 is not the only process running on the Raspberry
Pi. Each running program needs to share the ARM processor with the others. Because
of that, sometimes the execution of the program driving the TLC5940 gets paused,
to give an other process the processor. And with our process paused, the &lt;code&gt;GSCLK&lt;/code&gt;
signal generation gets also paused, resulting is a less stable PWM signal.&lt;/p&gt;

&lt;p&gt;This is a bit hard to fix, because you need to keep track of the pulse count,
to send a pulse to the &lt;code&gt;blank&lt;/code&gt; pin on the right moment. Any suggestions for
solutions are always welcome.&lt;/p&gt;

&lt;h2 id=&#34;documentation&#34;&gt;Documentation&lt;/h2&gt;

&lt;p&gt;Because the TLC5940 constantly needs a stable clock, multithreading is a must
in your program. You need one thread which determines which outputs
need what value, and stores that in a buffer. The other thread constantly
reads that buffer and sends the data to the TLC5940. Please view the provided
sample program for a simple example. Luckily, multithreading isn&amp;rsquo;t that hard
anymore with C++11. For a simple introduction, check &lt;a href=&#34;https://lucasvandijk.nl/2012/05/introduction-to-threads-with-c-11/&#34; target=&#34;_blank&#34;&gt;this tutorial&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;tutorial&#34;&gt;Tutorial&lt;/h3&gt;

&lt;p&gt;First you need to decide which pins you&amp;rsquo;re going to use on the Raspberry Pi.
Please take a look at the &lt;a href=&#34;https://projects.drogon.net/raspberry-pi/wiringpi/pins/&#34; target=&#34;_blank&#34;&gt;wiringPi site&lt;/a&gt; with all the pin numbers. To
control your TLC5940, you&amp;rsquo;ll need 7 GPIO pins. If you&amp;rsquo;re not going to use the
&amp;ldquo;Dot Correction&amp;rdquo; feature of the TLC5940, you&amp;rsquo;ll need 5. Dot correction is also
not supported in this library for now, but it will probably in the future.
Below is the list of the pins on the TLC5940 which need to be controlled by the
Raspberry Pi.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SIN&lt;/li&gt;
&lt;li&gt;SCLK&lt;/li&gt;
&lt;li&gt;BLANK&lt;/li&gt;
&lt;li&gt;XLAT&lt;/li&gt;
&lt;li&gt;GSPRG&lt;/li&gt;
&lt;li&gt;DCPRG (connect to ground if not using Dot Correction)&lt;/li&gt;
&lt;li&gt;VPRG (connect to ground if not using Dot Correction)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You&amp;rsquo;re free to choose any pin on the Raspberry Pi, but keep the &lt;a href=&#34;https://projects.drogon.net/raspberry-pi/wiringpi/special-pin-functions/&#34; target=&#34;_blank&#34;&gt;special pin functions&lt;/a&gt;
in mind. Define the pins in your code using multiple instances of the class
&lt;code&gt;RaspberryGPIOPin&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;RaspberryGPIOPin tlc_sin(1);
RaspberryGPIOPin tlc_sclk(14);
RaspberryGPIOPin tlc_blank(4);
RaspberryGPIOPin tlc_dcprg(5);
RaspberryGPIOPin tlc_vprg(6); 
RaspberryGPIOPin tlc_xlat(10);
RaspberryGPIOPin tlc_gsclk(11);

tlc_sin.setOutput();
tlc_sclk.setOutput();
tlc_blank.setOutput();
tlc_dcprg.setOutput();
tlc_vprg.setOutput();
tlc_xlat.setOutput();
tlc_gsclk.setOutput();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The number given with the &lt;code&gt;RaspberryGPIOPin&lt;/code&gt; constructor represents the &lt;strong&gt;wiringPi
pin number&lt;/strong&gt;, not the BCM GPIO number. See the wiringPi site for the numbers.&lt;/p&gt;

&lt;p&gt;Controlling the TLC5940 starts with an instance of the class TLCController. This
class needs a template parameter, containing the number of cascaded TLC5940 chips.
The class also needs to know which pins you&amp;rsquo;re going to use, so the GPIO pin instances
created above are passed along.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;TLCController&amp;lt;2&amp;gt; tlc_controller(&amp;amp;tlc_sin, &amp;amp;tlc_sclk, &amp;amp;tlc_blank, &amp;amp;tlc_dcprg, &amp;amp;tlc_vprg, &amp;amp;tlc_xlat, &amp;amp;tlc_gsclk);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you have just a single TLC5940, you can use the SingleTLCController class.&lt;/p&gt;

&lt;p&gt;To enable an output, you use the &lt;code&gt;setChannel&lt;/code&gt; method. &lt;code&gt;setall&lt;/code&gt; sets the specified value
for all channels.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;tlc_controller.setChannel(0, 2048); // Set channel 0 to half of the brightness
tlc_controller.setChannel(1, 4095); // Set channel 1 to full brightness
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using the &lt;code&gt;update&lt;/code&gt; method, the data is sent to the TLC5940. Remember, this function
needs to be called continuously, even if you don&amp;rsquo;t changed any output values.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;tlc_controller.update();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;linking&#34;&gt;Linking&lt;/h3&gt;

&lt;p&gt;This library provides a &lt;code&gt;pkg-config&lt;/code&gt; configuration file, so you can use pkg-config
to retrieve the required compiler and linker flags.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;CFLAGS += `pkg-config --cflags tlc5940-raspberry-1.0`
LDFLAGS += `pkg-config --libs tlc5940-raspberry-1.0`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And if you use autotools as build system you can use the &lt;code&gt;PKG_CHECK_MODULES&lt;/code&gt; macro,
see &lt;a href=&#34;http://www.flameeyes.eu/autotools-mythbuster/pkgconfig/pkg_check_modules.html&#34; target=&#34;_blank&#34;&gt;this&lt;/a&gt; site for more info.&lt;/p&gt;

&lt;h2 id=&#34;download-and-install&#34;&gt;Download and Install&lt;/h2&gt;

&lt;p&gt;This project is hosted on &lt;a href=&#34;https://github.com/lrvdijk/tlc5940-raspberry&#34; target=&#34;_blank&#34;&gt;Github&lt;/a&gt;. To get the latest version you can use Git to clone the repository.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git clone http://github.com/lrvdijk/tlc5940-raspberry&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Or you can just download the code &lt;a href=&#34;https://github.com/lrvdijk/tlc5940-raspberry/archive/master.zip&#34; target=&#34;_blank&#34;&gt;from here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;installation&#34;&gt;Installation&lt;/h3&gt;

&lt;p&gt;Download the latest version on your Raspberry Pi, and extract its contents.
Navigate to the right folder, and execute the following commands:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./autogen --prefix=/usr
make
sudo make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s better to install the library in /usr instead of the default /usr/local,
because by default &lt;code&gt;pkg-config&lt;/code&gt; doesn&amp;rsquo;t check the /usr/local folders for
package config files.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Controlling a servo with an AVR microcontroller</title>
      <link>https://lucasvandijk.nl/2012/10/controlling-a-servo-with-an-avr-microcontroller/</link>
      <pubDate>Tue, 16 Oct 2012 00:00:00 +0000</pubDate>
      
      <guid>https://lucasvandijk.nl/2012/10/controlling-a-servo-with-an-avr-microcontroller/</guid>
      <description>&lt;p&gt;Welcome to my first AVR tutorial on this site! We&amp;rsquo;ll be doing something basic
today, namely controlling a servo. There are a lot of tutorials on how to
control it with an Arduino, but less tutorials using only a bare AVR chip. In
this tutorial we&amp;rsquo;ll be using the ATTiny44, a small and cheap microprocessor,
which also contains a &lt;strong&gt;16 bit timer&lt;/strong&gt;, which will make our life a bit easier.&lt;/p&gt;

&lt;p&gt;Servos are often used to move robot arms and things alike, because they can rotate a specific amount of degrees very precisely, depending on the pulsewidth you feed it with the microcontroller. They can also be used as a motor (you&amp;rsquo;ll need special &amp;lsquo;continuous rotation&amp;rsquo; servos for that), you&amp;rsquo;ll often find them in RC cars.&lt;/p&gt;

&lt;p&gt;So lets get started, and see how you actually control a servo!&lt;/p&gt;

&lt;h2 id=&#34;pulse-width-modulation&#34;&gt;Pulse width modulation&lt;/h2&gt;

&lt;p&gt;To move the servo, you need to send it a pulse. Depending on the duration of the pulse, the servo positions itself in a fixed position. This position is unique to the pulse duration. In other words, no matter what the current position of the servo is, it always rotates to the same position for a certain pulse duration. The following pulse durations result in the following positions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1ms: 90 degrees to the left&lt;/li&gt;
&lt;li&gt;1.5ms: Center position&lt;/li&gt;
&lt;li&gt;2ms: 90 degrees to the right&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For most servos the maximum frequency is around 50 Hz, which means a time period of 20ms. The servo is of course not limited to the above corners, the corner is proportional to the pulse duration, with a minimum of 0.7ms and a maximum of 2.3ms.&lt;/p&gt;

&lt;h2 id=&#34;implementing-it-with-an-avr-microcontroller&#34;&gt;Implementing it with an AVR microcontroller&lt;/h2&gt;

&lt;p&gt;Lets start with the circuit, which is really simple.&lt;/p&gt;






&lt;p&gt;
    &lt;figure &gt;
        
            &lt;img src=&#34;https://lucasvandijk.nl/img/blogimages/servoschema.jpg&#34; alt=&#34;
Circuit with an AVR ATTiny44 to control a servo
&#34; /&gt;
        
        
        &lt;figcaption&gt;
Circuit with an AVR ATTiny44 to control a servo
&lt;/figcaption&gt;
        
    &lt;/figure&gt;
&lt;/p&gt;



&lt;p&gt;In this case, I use a 9V battery to power my AVR, and 4 AA batteries (total of
6V), to power my servo. It&amp;rsquo;s better to use a different power source for your
servos, because they can draw high currents when they&amp;rsquo;re rotating, and
therefore possibly trigger your reset of the AVR resulting from the voltage
drop.&lt;/p&gt;

&lt;p&gt;I use the LM7805 to transform the 9V to 5V for the AVR, some capacitors to remove any AC components of the voltage, and a 4.7k resistor as a pull up for the reset pin. As you can see, nothing special here. More interesting is the source code running on the AVR.&lt;/p&gt;

&lt;h3 id=&#34;avr-source-code&#34;&gt;AVR source code&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* -*- Mode: C; indent-tabs-mode: t; c-basic-offset: 4; tab-width: 4 -*- */
/*
 * main.c - Auto-generated by Anjuta&#39;s Makefile project wizard
 * 
 */

#ifndef F_CPU
#define F_CPU 1000000L
#endif

#include &amp;lt;avr/io.h&amp;gt;
#include &amp;lt;avr/interrupt.h&amp;gt;
#include &amp;lt;stdint.h&amp;gt;

#define SERVO_PWM_TOP 10000UL // 50 Hz PWM
#define SERVO_LEFT 500UL // Capture value to position the servo to the left (1.0ms)
#define SERVO_CENTER 750UL // Capture value to position the servo in the center (pulse width 1.5ms)
#define SERVO_RIGHT 1000UL // Capture value to turn the servo (pulse width 2ms)

int main(void)
{
	// Setup ports and timers
	DDRA = 0xFF; // All output
	PORTA = 0;

	// Configure timer/counter1 as phase and frequency PWM mode
	TCNT1 = 0;
	TCCR1A = (1 &amp;lt;&amp;lt; COM1A1);
	TCCR1B = (1 &amp;lt;&amp;lt; WGM13) | (1 &amp;lt;&amp;lt; CS10);
	ICR1 = SERVO_PWM_TOP;
	OCR1A = SERVO_LEFT;

	while(1)
	{
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, what are we doing here? We&amp;rsquo;re going to use the PWM hardware to generate the pulse we want. The ATTiny44 contains a 16 bit timer, which has a special mode called &amp;lsquo;Frequency and phase correct PWM&amp;rsquo;. Grab the &lt;a href=&#34;http://www.atmel.com/Images/doc8006.pdf&#34; title=&#34;ATTiny44 Datasheet&#34; target=&#34;_blank&#34;&gt;ATTiny44 datasheet&lt;/a&gt;, and read about it.&lt;/p&gt;

&lt;p&gt;To summarize what is does: you start with providing two values: a TOP value, and a compare value. The AVR will then count to the TOP value, and after it reached that, it counts back to zero. When the counter has the same value as in OCR1A, something will happen: in the case of up counting, it will reset the pin value of OCA1 to 0, and when down counting, it sets the pin value to 1. This behaviour can be changed by setting the right bits in the TCCR1A/B/C registers. Read the datasheet for more information.&lt;/p&gt;

&lt;p&gt;To visualize a bit what&amp;rsquo;s happening, here&amp;rsquo;s a drawing:&lt;/p&gt;






&lt;p&gt;
    &lt;figure &gt;
        
            &lt;img src=&#34;https://lucasvandijk.nl/img/blogimages/servo-timer-match.jpg&#34; alt=&#34;
Value of the timer, and the match events
&#34; /&gt;
        
        
        &lt;figcaption&gt;
Value of the timer, and the match events
&lt;/figcaption&gt;
        
    &lt;/figure&gt;
&lt;/p&gt;



&lt;p&gt;Some things you can conclude from the above drawing and description: The value
in ICR1 defines the frequency, the value in OCR1A defines the duty cycle.&lt;/p&gt;

&lt;h3 id=&#34;calculating-the-values-for-icr1-and-ocr1a&#34;&gt;Calculating the values for ICR1 and OCR1A&lt;/h3&gt;

&lt;p&gt;So why does the above code has 10000 as value for ICR1, and 500/750/1000 for OCR1A? With a few simple calculations, you can get the values you need:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Check at which clockfrequency your AVR runs, in our case it&amp;rsquo;s 1 MHz.&lt;/li&gt;
&lt;li&gt;Because it runs on 1 MHz, if we had an unlimited number of bits for our counter, it would count to 1000000 in one second.&lt;/li&gt;
&lt;li&gt;Almost all servos operate at a frequency of 50 Hz, which means a time period of 20 ms.&lt;/li&gt;
&lt;li&gt;You know this: 1000000 for one second, so 1000000 * (20*10^-3) = 20000 counts for 20 ms.&lt;/li&gt;
&lt;li&gt;In phase and frequency correct mode, it counts up AND down, to we devide the above number by 2, which results in 10000, the value for ICR1. This is why a 16 bit timer is useful, because 10000 easily fits in 16 bits, and definitely not in 8 bits.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The same can be done to position the servo at the left (a pulse of 1 ms), or at the right (a pulse of 2 ms).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Please note that the above code will constantly pulse every 20 ms.&lt;/strong&gt; If the servo is already in the right position, it will not move. And it&amp;rsquo;s probably better to disable the timer, when you&amp;rsquo;ve sent the pulse. That&amp;rsquo;s left as an exercise for the reader. ;)&lt;/p&gt;

&lt;h2 id=&#34;troubleshooting&#34;&gt;Troubleshooting&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;In general, it&amp;rsquo;s better to use a separate power source for the servos, to avoid triggering the reset of the AVR. But remember: the grounds of each power source should be connected!&lt;/li&gt;
&lt;li&gt;If you want your servo to rotate continuously, remember to buy a servo which is capable of doing that. Most servos can&amp;rsquo;t rotate a full 360 degrees. However, there are mods to modify a non-continuous rotation servo to one that can rotate the full 360 degrees. Using Google, you can find a lot of tutorials to do that. And it&amp;rsquo;s quite easy.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Thanks for reading, and I hope you enjoyed the article!&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Multithreading with C&#43;&#43;11: protecting data</title>
      <link>https://lucasvandijk.nl/2012/06/multithreading-with-c-11-protecting-data/</link>
      <pubDate>Thu, 14 Jun 2012 00:00:00 +0000</pubDate>
      
      <guid>https://lucasvandijk.nl/2012/06/multithreading-with-c-11-protecting-data/</guid>
      <description>&lt;p&gt;Welcome to this second part in a series of articles about multithreading with C++11.
In the previous part, I briefly explained what a thread is, and how to create one with the new C++ thread library.
This time, we will be writing a lot more code, so open up your favourite IDE if you want to try the examples while you&amp;rsquo;re reading.&lt;/p&gt;

&lt;p&gt;In the previous article we also saw that sometimes, the output wasn&amp;rsquo;t completely right when running multiple threads simultaneously. Today,
we&amp;rsquo;ll see that there are some other problems with sharing a resource between threads, and of course, provide some solutions to these
problems.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;This is an article part of a series about multithreading with C++11, the other
parts are listed below:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Part 1: &lt;a href=&#34;https://lucasvandijk.nl/2012/05/introduction-to-threads-with-c-11/&#34; target=&#34;_blank&#34;&gt;Introduction to threads with C++11&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Part 2: Protecting your data with multiple threads&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;lost-data&#34;&gt;Lost data&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s start with a simple example. Consider the following program:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;thread&amp;gt;
#include &amp;lt;vector&amp;gt;

using std::thread;
using std::vector;
using std::cout;
using std::endl;

class Incrementer
{
	private:
		int counter;

	public:
		Incrementer() : counter{0} { };

		void operator()()
		{
			for(int i = 0; i &amp;lt; 100000; i++)
			{
				this-&amp;gt;counter++;
			}
		}

		int getCounter() const
		{
			return this-&amp;gt;counter;
		}		
};

int main()
{
	// Create the threads which will each do some counting
	vector&amp;lt;thread&amp;gt; threads;

	Incrementer counter;

	threads.push_back(thread(std::ref(counter)));
	threads.push_back(thread(std::ref(counter)));
	threads.push_back(thread(std::ref(counter)));

	for(auto &amp;amp;t : threads)
	{
		t.join();
	}

	cout &amp;lt;&amp;lt; counter.getCounter() &amp;lt;&amp;lt; endl;
	
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The purpose of this program is to count to 300000. Some smartass programmer wanted to optimize the counting,
and created three threads, each adding 100000 times one to a shared variable &lt;code&gt;counter&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s walk a bit through the code. We create a new class called &lt;code&gt;Incrementer&lt;/code&gt;, which holds a private variable
&lt;code&gt;counter&lt;/code&gt;. The constructor is really simple, simply initializing &lt;code&gt;counter&lt;/code&gt;, by setting it to zero.&lt;/p&gt;

&lt;p&gt;What follows is an operator overloading function, and in this case &lt;code&gt;operator()&lt;/code&gt;. This means that each object of
this class, can be called as a simple function. Normally you would call a method on an object like this:
&lt;code&gt;object.fooMethod()&lt;/code&gt;, but now, you can actually &lt;em&gt;call&lt;/em&gt; the object, like this: &lt;code&gt;object()&lt;/code&gt;. This is convenient, because
now we can pass the whole object to the thread class, and within the operator overloading function, use all advantages
of a class. And the last method of the class is &lt;code&gt;getCounter&lt;/code&gt;, a simple getter for the &lt;code&gt;counter&lt;/code&gt; variable.&lt;/p&gt;

&lt;p&gt;Then, we have the &lt;code&gt;main()&lt;/code&gt; function, here we create the threads in a similar manner as in the previous article. A few
differences though: we now create an object of the class &lt;code&gt;Incrementer&lt;/code&gt;, and we pass it to the threads. Note that we use
&lt;code&gt;std::ref&lt;/code&gt; here, to pass a reference of the object, instead of passing a copy to the thread.&lt;/p&gt;

&lt;p&gt;So, let&amp;rsquo;s see what this program produces, and if this smartass programmer is really smart. Compile the program using
GCC 4.7 or higher, or Clang 3.1 or higher. In case of GCC, use the following command:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;g++ -std=c++11 -lpthread -o threading_example main.cpp&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;And voilà, the output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[lucas@lucas-desktop src]$ ./threading_example 
218141
[lucas@lucas-desktop src]$ ./threading_example 
208079
[lucas@lucas-desktop src]$ ./threading_example 
100000
[lucas@lucas-desktop src]$ ./threading_example 
202426
[lucas@lucas-desktop src]$ ./threading_example 
172209
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But wait a second! That smartass programmer wasn&amp;rsquo;t so smart after all! The program doesn&amp;rsquo;t count to 300000, one run
only reached the 100000! Why is this happening? Well, as simple as &amp;lsquo;increment by one&amp;rsquo; sounds, it actually requires
multiple instructions for the processor to increment the right variable:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gas&#34;&gt;movl	counter(%rip), %eax
addl	$1, %eax
movl	%eax, counter(%rip)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What happens is this:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;We have the current counter value stored in memory, and we load that value into the EAX register&lt;/li&gt;
&lt;li&gt;We add one to the value in the EAX register&lt;/li&gt;
&lt;li&gt;We store the value in EAX back in the original memory location&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I hear you think: &amp;ldquo;Ok, nice information, but how does this solve my counting problem smartass?&amp;rdquo;. Well, remember from
the previous article, that threads shared the processor, if there&amp;rsquo;s only one core. So at some point, one thread is
really happy because his instructions are executed for a while, but then comes the big boss operating system saying
&amp;ldquo;Ok, time&amp;rsquo;s up, back in the line!&amp;rdquo;, and then another thread will be executed for a while. And when it&amp;rsquo;s the turn of the
original thread again, he starts executing where he was left. So, can you guess what happens, if the operating system
gives another thread the processor, while the original thread was in the middle of the process of incrementing the value
of a variable by one? Well, for example this:&lt;/p&gt;

&lt;table&gt;
&lt;tr&gt;
&lt;th width=&#34;25%&#34;&gt;Thread 1&lt;/th&gt;
&lt;th width=&#34;25%&#34;&gt;Thread 2&lt;/th&gt;
&lt;th width=&#34;5%&#34;&gt;Counter&lt;/th&gt;
&lt;th width=&#34;55%&#34;&gt;Explanation&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%eax &lt;- counter&lt;/td&gt;
&lt;td&gt;nothing&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;The current value of the counter is now stored in EAX&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%eax + 1&lt;/td&gt;
&lt;td&gt;nothing&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;The value in EAX is now 2, but the counter hasn&#39;t been updated yet&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;nothing&lt;/td&gt;
&lt;td&gt;%eax &lt;- counter&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;Hey, a switch to the other thread, and because the counter hasn&#39;t been updated, it loads the old value&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%eax -&gt; counter&lt;/td&gt;
&lt;td&gt;nothing&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;And we&#39;re back at thread 1. When a thread switches, the state of the registers (for example EAX), are saved, and when we switch back, they&#39;re restored in their original state. Because EAX was two the last time thread one got interrupted, that value will be written in the counter variable.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;nothing&lt;/td&gt;
&lt;td&gt;%eax + 1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;And we&#39;re back at thread 2. The last time thread got interrupted, EAX had the value 1. &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;nothing&lt;/td&gt;
&lt;td&gt;%eax -&gt; counter&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;And because EAX was one (and is now two because of the previous instruction), the counter remains 2.&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;h2 id=&#34;hey-it-s-occupied&#34;&gt;Hey it&amp;rsquo;s occupied!&lt;/h2&gt;

&lt;p&gt;The solution is to make sure only one thread can access the shared variable at the same time. This can be done using the
&lt;a href=&#34;http://en.cppreference.com/w/cpp/thread/mutex&#34; title=&#34;std::mutex reference&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;std::mutex&lt;/code&gt;&lt;/a&gt; class. Visualize it as a sort of toilet: when you go inside, you lock it, do your stuff, and then you unlock it.
Anyone who wants to use the bathroom has to wait before you&amp;rsquo;re ready.&lt;/p&gt;

&lt;p&gt;A convenient feature of a mutex is that operating system makes sure the operations locking and unlocking are indivisible. This means that the thread will not be
interupted when it&amp;rsquo;s trying to lock or unlock a mutex. When a thread locks or unlocks a mutex, this operation will be finished
before the operating system switches threads.&lt;/p&gt;

&lt;p&gt;And the best thing is, when you try to lock a mutex, but some other thread already locked it, you&amp;rsquo;ll have to wait. But the operating
system keeps track which threads wait on which mutex. The blocked thread will go in a &amp;ldquo;blocked on &lt;em&gt;m&lt;/em&gt;&amp;rdquo; state, meaning that the
operating system won&amp;rsquo;t give that thread any processortime any more, until the mutex becomes unlocked. This means no wasted
CPU cycles. If there are multiple threads waiting, it depends on the operating system which thread will be the &amp;lsquo;winner&amp;rsquo;.
General purpose operating systems like Linux and Windows use a First In First Out system, on realtime operating systems it&amp;rsquo;s
priority based.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s modify above code, to make sure counting works as expected.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;thread&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;mutex&amp;gt;

using std::thread;
using std::vector;
using std::cout;
using std::endl;
using std::mutex;

class Incrementer
{
	private:
		int counter;
		mutex m;

	public:
		Incrementer() : counter{0} { };

		void operator()()
		{
			for(int i = 0; i &amp;lt; 100000; i++)
			{
				this-&amp;gt;m.lock();
				this-&amp;gt;counter++;
				this-&amp;gt;m.unlock();
			}
		}

		int getCounter() const
		{
			return this-&amp;gt;counter;
		}	
};

int main()
{
	// Create the threads which will each do some counting
	vector&amp;lt;thread&amp;gt; threads;

	Incrementer counter;

	threads.push_back(thread(std::ref(counter)));
	threads.push_back(thread(std::ref(counter)));
	threads.push_back(thread(std::ref(counter)));

	for(auto &amp;amp;t : threads)
	{
		t.join();
	}

	cout &amp;lt;&amp;lt; counter.getCounter() &amp;lt;&amp;lt; endl;
	
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note the changes: we included the &lt;code&gt;mutex&lt;/code&gt; header file, added a member &lt;code&gt;m&lt;/code&gt; to our class, with type &lt;a href=&#34;http://en.cppreference.com/w/cpp/thread/mutex&#34; title=&#34;std::mutex reference&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;mutex&lt;/code&gt;&lt;/a&gt;,
the standard mutex class in C++11. In the method &lt;code&gt;operator()()&lt;/code&gt;, we lock the mutex just before incrementing
the counter, and afterwards we unlock it again.&lt;/p&gt;

&lt;p&gt;When we run the program, the output is correct:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[lucas@lucas-desktop src]$ ./threading_example 
300000
[lucas@lucas-desktop src]$ ./threading_example 
300000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And as always in computer science, there&amp;rsquo;s no free lunch. Using mutexes will considerable slow down your
program, but that&amp;rsquo;s better than an incorrect program.&lt;/p&gt;

&lt;h2 id=&#34;heimdall-guard-us-against-exceptions&#34;&gt;Heimdall, guard us against exceptions&lt;/h2&gt;

&lt;p&gt;When incrementing a variable by one, the chance of an exception being raised it not really high, but with more
complex code, it&amp;rsquo;s definitely possible. The above code is not really exception safe. When an exception
occurs, the mutex will still be locked, while the function is already finished.&lt;/p&gt;

&lt;p&gt;To make sure the mutex is unlocked when an exception is thrown, we could use the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;for(int i = 0; i &amp;lt; 100000; i++)
{
	this-&amp;gt;m.lock();
	try
	{
		this-&amp;gt;counter++;
		this-&amp;gt;m.unlock();
	}
	catch(...)
	{
		this-&amp;gt;m.unlock();
		throw;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But, that&amp;rsquo;s an awful lot of code, for just locking and unlocking a mutex. Luckily, there&amp;rsquo;s a nice simple
solution for that, the &lt;a href=&#34;http://en.cppreference.com/w/cpp/thread/lock_guard&#34; title=&#34;std::lock_guard reference&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;std::lock_guard&lt;/code&gt;&lt;/a&gt; class. The &lt;code&gt;lock_guard&lt;/code&gt; class is really simple: it
locks the given mutex on creation, and unlocks the mutex when the lock is destroyed (for example, at the
end of a function scope).&lt;/p&gt;

&lt;p&gt;Modifying the above code again results in:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void operator()()
{
	for(int i = 0; i &amp;lt; 100000; i++)
	{
		lock_guard&amp;lt;mutex&amp;gt; lock(this-&amp;gt;m);

		// The lock has been created now, and immediatly locks the mutex
		this-&amp;gt;counter++;

		// This is the end of the for-loop scope, and the lock will be
		// destroyed, and in the destructor of the lock, it will
		// unlock the mutex
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code is also exception safe, because when an exception occurs, the destructor of the lock will still
be called, resulting in an unlocked mutex.&lt;/p&gt;

&lt;p&gt;And remember, you can create your temporarily scopes in the following way:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void long_function()
{
	// some long code

	// Just a pair of curly braces
	{
		// Temp scope, create lock
		lock_guard&amp;lt;mutex&amp;gt; lock(this-&amp;gt;m);

		// do some stuff

		// Close the scope, so the guard will unlock the mutex
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;closing&#34;&gt;Closing&lt;/h2&gt;

&lt;p&gt;I promised in the previous article to explain why the printing of &amp;ldquo;Hello World&amp;rdquo; and &amp;ldquo;Parallel World&amp;rdquo;
sometimes went wrong. I hope you understand now that sharing resources between threads without
synchronization can cause problems.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m going to be a bit lazy here, and redirect you guys &lt;a href=&#34;http://stackoverflow.com/questions/6374264/is-cout-synchronized-thread-safe&#34; target=&#34;_blank&#34;&gt;to this stackoverflow question&lt;/a&gt;. To
fix the output of cout, just create another mutex, and each thread should lock that mutex before sending
something to cout, and of course unlock it when it&amp;rsquo;s done.&lt;/p&gt;

&lt;p&gt;I hope you enjoyed the article, and next time we&amp;rsquo;ll cover condition variables, another widely used technique
to synchronize threads.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Introduction to threads with C&#43;&#43;11</title>
      <link>https://lucasvandijk.nl/2012/05/introduction-to-threads-with-c-11/</link>
      <pubDate>Thu, 03 May 2012 00:00:00 +0000</pubDate>
      
      <guid>https://lucasvandijk.nl/2012/05/introduction-to-threads-with-c-11/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://www.gotw.ca/publications/concurrency-ddj.htm&#34; target=&#34;_blank&#34;&gt;The free lunch is over&lt;/a&gt;. The time that our complex algorithm was
running extremely slow on a computer, but ran extremely fast a few years later,
because the processor speeds exploded, is gone. The trend with current processors
is to add more cores, rather than increasing the clock frequency.&lt;/p&gt;

&lt;p&gt;As programmer, you should be aware of this. Of course, processors will always
perform a bit better each year, but the growth in performance is slowing down.
Currently, a lot of programs can benefit the most by using multiple threads,
because of today&amp;rsquo;s multicore processors.&lt;/p&gt;

&lt;p&gt;In this article I&amp;rsquo;ll briefly explain what a thread is, and how you can create
them with the new threading library in C++11. I&amp;rsquo;m planning to write multiple
articles about this topic, each going a little bit more in depth.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;This is part of a series of articles about multithreading with C++11, the
other parts are listed below:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Part 1: Introduction to threads with C++11&lt;/li&gt;
&lt;li&gt;Part 2: &lt;a href=&#34;https://lucasvandijk.nl/2012/06/multithreading-with-c-11-protecting-data/&#34; target=&#34;_blank&#34;&gt;Protecting your data when using multiple threads&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;what-is-a-thread&#34;&gt;What is a thread?&lt;/h2&gt;

&lt;p&gt;On most general purpose computers, we run a lot of processes beside each other.
But let us ask the question, what is a process? Well, a simple definition is a
running program. But what is a program then? Another simple definition is a list
of instructions the processor needs to execute.&lt;/p&gt;

&lt;p&gt;Assume we have one single-core processor. How can all these programs run beside
each other? After all, a single-core processor can perform only one instruction
at the time. Well, that&amp;rsquo;s handled by the operating system. To share the processor
with all these processes, it gives one process a little of bit of time to perform
some instructions, then goes to another process which gets a little bit of time
and so on. Some processes have higher priority than some other, and will get
more processor time than the other. This is called scheduling and is a subject
on itself, and I won&amp;rsquo;t cover it a lot more.&lt;/p&gt;

&lt;p&gt;Within processes, we can have threads. It&amp;rsquo;s a little bit the same principle
described above: on a single-core processor, each thread is given some processor-time.&lt;/p&gt;

&lt;p&gt;If we have a non-threading program, we start at the &lt;code&gt;main()&lt;/code&gt; function, and the
program is finished when we reach the end of the &lt;code&gt;main()&lt;/code&gt; function. Fun fact:
when you run this program, the operating system actually creates a new thread
to run the &lt;code&gt;main()&lt;/code&gt; function in, which we call the &amp;lsquo;main thread&amp;rsquo; (creative name,
isn&amp;rsquo;t it?).&lt;/p&gt;

&lt;p&gt;From the main thread, you can create new threads which should run simultaneous to the main
thread. This means that beside the &amp;lsquo;codepath&amp;rsquo; &lt;code&gt;main()&lt;/code&gt; till the end of &lt;code&gt;main()&lt;/code&gt;,
we now also have another codepath, from the entrypoint of the new thread, till
the end of the thread. The entrypoint of the thread is often the start of an other
function than &lt;code&gt;main()&lt;/code&gt;, and the end of the thread means the end of that function.
But remember, on a single-core processor, it&amp;rsquo;s not really simultaneous, it shares
the processor with the other threads.&lt;/p&gt;

&lt;p&gt;We talked a lot about single-core processors in the above text, but what about
today&amp;rsquo;s multicore processors? Well, this means we can actually do multiple things
at the same time. If your processor has two cores, then two threads can actually
run at the same time, without sharing the processor. If your processor has N
cores, then your processor can run N threads at the same time. And this is why
today multithreading is so important: we can actually do things in parallel.&lt;/p&gt;

&lt;h3 id=&#34;difference-between-processes-and-threads&#34;&gt;Difference between processes and threads&lt;/h3&gt;

&lt;p&gt;Threads and processes both have the same purpose: running specific tasks
simultaneous to each other. Why do they both exist? Well there are some differences,
summarized below.&lt;/p&gt;

&lt;h4 id=&#34;properties-of-a-process&#34;&gt;Properties of a process&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;The stack of a process is safe&lt;/li&gt;
&lt;li&gt;Each process has his own memory, which can&amp;rsquo;t be altered by other programs.
(Probably there are ways to do it, but in normal circumstances it can&amp;rsquo;t be done).

&lt;ul&gt;
&lt;li&gt;Because each process has it&amp;rsquo;s own memory, the memory is &lt;strong&gt;safe&lt;/strong&gt;, but inter-process communication
is &lt;em&gt;slow&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Switching from one process to another is heavy: processor-cache flush, memory
management unit TLB flush.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;properties-of-a-thread&#34;&gt;Properties of a thread&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;The stack of a thread is safe&lt;/li&gt;
&lt;li&gt;Each thread shares the same memory within the same process

&lt;ul&gt;
&lt;li&gt;Shared memory is &lt;strong&gt;unsafe&lt;/strong&gt;, but inter-process communication is &lt;em&gt;fast&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Switching from one thread to another is &lt;em&gt;fast&lt;/em&gt; (no flushes)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;please-give-me-some-code&#34;&gt;Please, give me some code!&lt;/h2&gt;

&lt;p&gt;Fine, fine, let&amp;rsquo;s start coding. The new threading library is really nice, and
makes creating a new thread really easy. Consider the example below, we&amp;rsquo;ll walk
through the code afterwards.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;thread&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;vector&amp;gt;

using std::string;
using std::thread;
using std::vector;
using std::cout;
using std::endl;

/**
 * Prints the given string `num_times` times, with `time_between` miliseconds
 * between each print.
 */ 
void printer(string text, int num_times, int time_between)
{
	for(int i = 0; i &amp;lt; num_times; i++) 
	{
		cout &amp;lt;&amp;lt; text &amp;lt;&amp;lt; endl;

		// Wait a moment before next print
		std::chrono::milliseconds duration(time_between);
		std::this_thread::sleep_for(duration);
	}
}

int main()
{
	// Create the threads which will each print something
	vector&amp;lt;thread&amp;gt; printers;

	printers.push_back(thread(printer, &amp;quot;Hello&amp;quot;, 30, 10));
	printers.push_back(thread(printer, &amp;quot;World&amp;quot;, 40, 15));
	printers.push_back(thread(printer, &amp;quot;Parallel World&amp;quot;, 40, 20));

	for(auto &amp;amp;p : printers)
	{
		p.join();
	}
	
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, we first include some library files. The &lt;code&gt;chrono&lt;/code&gt; library and the
&lt;code&gt;thread&lt;/code&gt; library are the most important here. Both are new in C++11. The &lt;code&gt;chrono&lt;/code&gt;
library provides some nice timing capabilities, and the &lt;code&gt;thread&lt;/code&gt; library the classes
for creating threads.&lt;/p&gt;

&lt;p&gt;Then we define a new function called &lt;code&gt;printer&lt;/code&gt;. This is a very simple function
which just prints the given text a number of times, with a given time in between.
You can see that the &lt;code&gt;chrono&lt;/code&gt; library provides a nice and clean way to define the
time between each print.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;main&lt;/code&gt; function is a bit more interesting, in here we create the other threads.
C++11 provides a class &lt;code&gt;thread&lt;/code&gt;. As you can see, we create three objects of this
class, and put them all in a vector.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;thread&lt;/code&gt; constructor accepts a function as the first argument, and the rest
of the arguments will be passed to the given function.&lt;/p&gt;

&lt;p&gt;Because the &lt;code&gt;vector&lt;/code&gt; implements the iterator API, we can use the new C++11 range
based for syntax, and on each &lt;code&gt;thread&lt;/code&gt; object we call the method &lt;code&gt;join&lt;/code&gt;. This
makes sure the calling thread will now wait for the joined thread to exit, before
it finishes itself (in this case the main thread, and thus the whole program).
In our case each of the printer threads has to exit before the main thread
finishes.&lt;/p&gt;

&lt;h3 id=&#34;running-the-program&#34;&gt;Running the program&lt;/h3&gt;

&lt;p&gt;When we compile and run this program, we get the following output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;HelloWorld

Parallel World
Hello
World
Parallel World
Hello
World
Hello
Parallel World
Hello
World
Hello
Parallel World
World
Hello
Hello
World
Parallel World
Hello
World
Hello
Parallel World
World
Parallel World
World
World
Parallel World
Parallel World
Parallel World
Parallel World
Parallel World
Parallel World
Parallel World
Parallel World
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So yeah, we can see that our printer threads run beside each other, and
not sequential.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s one thing to note here, although we have the following code:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;cout &amp;lt;&amp;lt; text &amp;lt;&amp;lt; endl;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;In the first line of the above output, the &amp;lsquo;Hello&amp;rsquo; and
&amp;lsquo;World&amp;rsquo; are not on seperate lines. Something is not completely right, but the why
and how to fix will be covered in my next article.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
